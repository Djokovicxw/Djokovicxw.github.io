{"meta":{"title":"Djokovicxw 的博客","subtitle":"世界只有10种人，一种懂二进制，一种不懂","description":"西南交大 2016 级大三在读，就职意向：前端或者后端开发。","author":"Djokovicxw","url":"http://makinoki.xyz","root":"/"},"pages":[],"posts":[{"title":"随笔","slug":"随笔","date":"2019-08-18T14:12:48.000Z","updated":"2019-08-18T14:13:13.803Z","comments":true,"path":"2019/08/18/随笔/","link":"","permalink":"http://makinoki.xyz/2019/08/18/随笔/","excerpt":"","text":"随笔","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://makinoki.xyz/tags/随笔/"}]},{"title":"测试","slug":"测试","date":"2019-08-18T13:14:58.000Z","updated":"2019-08-18T13:20:51.598Z","comments":true,"path":"2019/08/18/测试/","link":"","permalink":"http://makinoki.xyz/2019/08/18/测试/","excerpt":"","text":"人生苦短，我用 Python","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://makinoki.xyz/tags/test/"}]},{"title":"算法导论","slug":"算法导论","date":"2019-08-01T06:51:56.000Z","updated":"2019-08-19T12:35:43.175Z","comments":true,"path":"2019/08/01/算法导论/","link":"","permalink":"http://makinoki.xyz/2019/08/01/算法导论/","excerpt":"2.3 设计算法2.3.1 分治法思想将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。 步骤分解原问题为若干子问题，这些子问题是原问题的规模较小的实例。 解决这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。 合并这些子问题的解组成原问题的解。 下面是归并排序的实现：","text":"2.3 设计算法2.3.1 分治法思想将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。 步骤分解原问题为若干子问题，这些子问题是原问题的规模较小的实例。 解决这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。 合并这些子问题的解组成原问题的解。 下面是归并排序的实现： 123456789101112131415import mathdef Merge(A, p, q, r): L1 = [A[i] for i in range(p, q + 1)] L2 = [A[i] for i in range(q + 1, r + 1)] L1.append(math.inf) L2.append(math.inf) i, j = 0, 0 for k in range(p, r + 1): if (L1[i] &lt; L2[j]): A[k] = L1[i] i += 1 else: A[k] = L2[j] j += 1 123456def Merge_sort(A, p, r): if p &lt; r: q = (p + r) // 2 Merge_sort(A, p, q) Merge_sort(A, q + 1, r) Merge(A, p, q, r) 1234# testA = [2, 5, 1, 4, 6, 8, 0]Merge_sort(A, 0, len(A) - 1)A [0, 1, 2, 4, 5, 6, 8] 第四章 分治策略4.1 最大子数组问题对于数组 A，称其和最大的非空连续子数组为最大子数组。 1# 分治法 第十五章 动态规划为了刷贪心的题，决定提前学习下贪心算法，结果打开书，告诉我学习贪心算法要先学习一下动态规划，于是，我开始了。 动态规划方法通常用来求解最优化问题。 设计动态规划算法的 4 个步骤： 刻画一个最优解的结构特征。 递归地定义最优解的值。 计算最优解的值，通常采用自底向上的方法。 利用计算出的信息构造一个最优解。 *重点在于对于重复求解的子问题，将其解保存起来，以空间换时间（time-memory-trade-off） 123456789101112131415161718192021222324# 钢条切割问题import mathp = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30]def Memoized_Cut_Rod_Aux(p, n, r): if r[n] &gt;= 0: return r[n] if n == 0: q = 0 else: q = -math.inf for i in range(1, n + 1): try: q = max(q, p[i] + Memoized_Cut_Rod_Aux(p, n - i, r)) except IndexError: pass r[n] = q return qdef Memoized_Cut_Rod(p, n): r = [-math.inf for i in range(0, n + 1)] print(len(r)) return Memoized_Cut_Rod_Aux(p, n, r) 1234567891011def Bottom_Up_Cut_Rod(p, n): r = [0] for j in range(1, n + 1): q = -1 for i in range(1, j + 1): try: q = max(q, p[i] + r[j - i]) except IndexError: pass r.append(q) return r[n] 1Bottom_Up_Cut_Rod(p, 20) 60 12Bottom_Up_Cut_Rod(p, 50)# 150 123456# 斐波那契数列的 O(n) 实现 -- 动态规划思想def Fib(n): r = [1, 2] for i in range(2, n): r.append(r[i-1] + r[i-2]) return r[-1] 1Fib(20) 10946 15.2 矩阵链乘法问题描述：给定 n 个矩阵 &lt;A_1, A_2, …, A_n&gt;，求完全括号化方案，使得计算 A_1 * A_2 * A_3 * … * A_n 所需标量乘法次数最少。 A[n] 矩阵链。为了方便，用序列 p = &lt; p0, p1, p2, … pn &gt; 表示， A[i] 的规模 = p[i-1] * p[i]。这样可以保证矩阵链中的矩阵都是可容的。用 m[i, j] 表示 A[i] * A[i+1] * … * A[j] 需要的最少乘法次数。显然，m[i, i] = 0 且问题的解为 m[1, n] 12345678910111213141516def Matirx_Chain_Order(p): n = len(p) - 1 # n -&gt; nums of matrix m = [[0 for i in range(n + 1)] for j in range(n + 1)] s = [[0 for _ in range(n + 1)] for j in range(n + 1)] for l in range(2, n + 1): ## l is the length of chain for i in range(1, n - l + 2): j = i + l - 1 m[i][j] = math.inf for k in range(i, j): q = m[i][k] + m[k + 1][j] + p[i-1] * p[k] * p[j] if q &lt; m[i][j]: m[i][j] = q s[i][j] = k return m[1][-1] 12p = [30, 35, 15, 5, 10, 20, 25]Matirx_Chain_Order(p) 15125","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://makinoki.xyz/tags/算法/"}]}]}